#pragma once

#include "Common/primitive_type.h"
#include "Math/TVector3.h"
#include "FileIO/SDL/TCommandInterface.h"
#include "Math/Transform/TDecomposedTransform.h"
#include "Core/Filmic/filmic_fwd.h"

#include <iostream>
#include <memory>

namespace ph
{

class Ray;
class Sample;
class SampleGenerator;
class InputPacket;
class Transform;
class RayDifferential;

class Camera : public TCommandInterface<Camera>
{
public:
	Camera();
	Camera(const Vector3R& position, const Vector3R& direction, const Vector3R& upAxis);
	virtual ~Camera() = 0;

	// TODO: precalculate aspect ratio info from camera film

	// Given a raster-space position on the film, generate a corresponding ray
	// that would have hit that position from the light entry of the camera (i.e., 
	// the furthest plane parallel to film the camera's lens system can reach).
	virtual void genSensedRay(const Vector2R& rasterPosPx, Ray* out_ray) const = 0;

	// Given a ray generated by genSensedRay() along with the parameters for it, 
	// calculates differential information on the origin of the ray.
	// The default implementation uses numerical differentiation for 
	// the differentials.
	virtual void calcSensedRayDifferentials(const Vector2R& rasterPosPx, const Ray& sensedRay, 
	                                        RayDifferential* out_result) const;

	virtual void evalEmittedImportanceAndPdfW(const Vector3R& targetPos, Vector2R* const out_filmCoord, Vector3R* const out_importance, real* out_filmArea, real* const out_pdfW) const = 0;

	inline void setRasterSize(const uint32 rasterWidth, const uint32 rasterHeight)
	{
		if(rasterWidth == 0 || rasterHeight == 0)
		{
			std::cerr << "warning: at Camera::setRasterSize(), input contains zero" << std::endl;
		}

		m_rasterWidth  = rasterWidth;
		m_rasterHeight = rasterHeight;
		onRasterSizeSet(rasterWidth, rasterHeight);
	}

	inline uint32 getRasterWidth() const
	{
		return m_rasterWidth;
	}

	inline uint32 getRasterHeight() const
	{
		return m_rasterHeight;
	}

	inline const Vector3R& getPosition() const
	{
		return m_position;
	}

	inline const Vector3R& getDirection() const
	{
		return m_direction;
	}

	inline const Vector3R& getUpAxis() const
	{
		return m_upAxis;
	}

	inline void getPosition(Vector3R* const out_position) const
	{
		m_position.set(out_position);
	}

	inline void getDirection(Vector3R* const out_direction) const
	{
		m_direction.set(out_direction);
	}

	virtual void onRasterSizeSet(uint32 newRasterWidth, uint32 newRasterHeight);

protected:
	TDecomposedTransform<hiReal> m_cameraToWorldTransform;

private:
	Vector3R m_position;
	Vector3R m_direction;
	Vector3R m_upAxis;

	uint32 m_rasterWidth;
	uint32 m_rasterHeight;

	void updateCameraToWorldTransform(const Vector3R& position, const Vector3R& direction, const Vector3R& upAxis);

// command interface
public:
	Camera(const InputPacket& packet);
	static SdlTypeInfo ciTypeInfo();
	static void ciRegister(CommandRegister& cmdRegister);
};

}// end namespace ph